# Требования: Поддержка Test элементов в MVP веб-версии

## Текущее состояние

В MVP веб-версии **не реализована** поддержка элементов типа `test`. В настоящее время MVP поддерживает только элементы типа `message`, `quiz`, `audio`, `input`, `question` и `multi_choice`.

## Описание Test элемента

Согласно документации `docs/elements.md`, элемент `test` представляет собой итоговый тест с подсчетом баллов по всем элементам с указанным префиксом. Используется для подведения итогов прохождения курса или модуля, оценки знаний пользователя на основе его ответов на вопросы с префиксом.

## Требования к реализации

### Параметры Test элемента

Согласно документации, элемент `test` должен поддерживать следующие параметры:

- `type`: `test` (обязательно)
- `text` (обязательно) - текст результата с поддержкой переменных:
  - `{score}` - набранные баллы (сумма score по всем элементам с префиксом)
  - `{maxscore}` - максимальные баллы (сумма max_score по всем элементам с префиксом)
- `prefix` (обязательно) - префикс ID элементов для подсчета (например, `q_` для элементов `q_1`, `q_2`, `Test_Score_` для элементов `Test_Score_01`, `Test_Score_02`)
- `score` (обязательно) - словарь с оценками по проценту ошибок:
  - Ключ - максимальный процент ошибок (число от 0 до 100)
  - Значение - сообщение для этого диапазона
  - Сообщение выбирается по первому ключу, где процент ошибок <= ключа (от меньшего к большему)
- `button` (опционально) - текст кнопки для продолжения после показа результата

### Поведение Test элемента

1. При отображении Test элемента:
   - Система ищет все элементы с ID, начинающимся с `prefix` в текущем курсе
   - Для каждого найденного элемента проверяется наличие ответа пользователя в БД (в таблице `conversation`)
   - Собираются все `score` и `max_score` из `json_data` ответов пользователя
   - Вычисляется сумма `score` и сумма `max_score`
   - Вычисляется процент ошибок: `(maxscore - score) / maxscore * 100`
   - Выбирается сообщение из `score` по проценту ошибок (берется первое, где процент ошибок <= ключа, сортировка по возрастанию ключа)
   - Подставляются переменные `{score}` и `{maxscore}` в текст `text`
   - Отображается итоговый текст с результатом и выбранным сообщением

2. После отображения результата:
   - Если указан `button`, отображается кнопка для продолжения
   - При нажатии на кнопку курс переходит к следующему элементу
   - Если `button` не указан, элемент автоматически переходит к следующему через несколько секунд

### Алгоритм подсчета баллов

1. **Поиск элементов с префиксом:**
   - Загрузить YAML файл курса
   - Найти все элементы, у которых `element_id.startswith(prefix)`
   - Отфильтровать только элементы типов, которые могут иметь оценки: `quiz`, `input`, `multi_choice`

2. **Сбор результатов из БД:**
   - Для каждого найденного элемента с префиксом:
     - Найти запись в таблице `conversation` с `element_id`, `chat_id`, `course_id`, `run_id`, `role='user'`
     - Извлечь из `json_data` поля `score` и `max_score` из `user_answer`
     - Если ответ не найден, считать `score=0` и `max_score` равным максимальному возможному для этого типа элемента:
       - `quiz`: `max_score=1`
       - `input`: `max_score=1` (если есть `correct_answer`)
       - `multi_choice`: `max_score=1.0`

3. **Вычисление итогов:**
   - `total_score = sum(score для всех элементов)`
   - `total_max_score = sum(max_score для всех элементов)`
   - Если `total_max_score == 0`, то `total_score = 0`, `total_max_score = 1` (избежать деления на ноль)

4. **Вычисление процента ошибок:**
   - `error_percentage = (total_max_score - total_score) / total_max_score * 100`
   - Округлить до 2 знаков после запятой

5. **Выбор сообщения:**
   - Отсортировать ключи словаря `score` по возрастанию
   - Найти первый ключ, где `error_percentage <= key`
   - Если такого ключа нет, использовать сообщение с максимальным ключом (или сообщение по умолчанию)

6. **Подстановка переменных:**
   - Заменить `{score}` на `total_score` (округлить до целого или 1 знака после запятой)
   - Заменить `{maxscore}` на `total_max_score` (округлить до целого или 1 знака после запятой)

### Особенности реализации

- **Типы элементов с оценками:**
  - `quiz`: `score` = 0 или 1, `max_score` = 1
  - `input`: `score` = 0 или 1, `max_score` = 1 (только если указан `correct_answer`)
  - `multi_choice`: `score` = 0.0, 0.5 или 1.0, `max_score` = 1.0
  - `question`: не учитывается (всегда `score=0`, `max_score=0`)

- **Обработка отсутствующих ответов:**
  - Если пользователь не ответил на элемент с префиксом, считается как `score=0`
  - `max_score` берется из максимально возможного для типа элемента

- **Обработка нескольких попыток:**
  - Если пользователь ответил на элемент несколько раз, берется последний ответ (по `conversation_id DESC`)

- **Форматирование чисел:**
  - `score` и `maxscore` могут быть целыми или дробными (для `multi_choice`)
  - При подстановке в текст можно округлить до 1 знака после запятой или до целого

## Требования к реализации

### Backend (`webapp/backend/app/api/v1/mvp.py`)

#### 1. Pydantic модели

```python
class TestElement(BaseModel):
    element_id: str
    type: str = Field(default="test", exclude=False)
    text: str
    prefix: str
    score: Dict[int, str]  # Ключ - процент ошибок, значение - сообщение
    button: Optional[str] = None

class TestResultResponse(BaseModel):
    total_score: float
    total_max_score: float
    error_percentage: float
    result_text: str  # Текст с подставленными переменными
    feedback_message: str  # Выбранное сообщение из score
```

#### 2. Функция подсчета баллов

```python
def calculate_test_score(
    chat_id: int,
    course_id: str,
    run_id: int,
    prefix: str
) -> tuple[float, float]:
    """
    Подсчитывает сумму баллов по всем элементам с префиксом
    
    Возвращает:
    - (total_score, total_max_score)
    """
    # 1. Загрузить курс и найти элементы с префиксом
    # 2. Для каждого элемента найти ответ в БД
    # 3. Собрать score и max_score
    # 4. Вернуть суммы
    pass
```

#### 3. Функция выбора сообщения

```python
def select_test_feedback(
    error_percentage: float,
    score_dict: Dict[int, str]
) -> str:
    """
    Выбирает сообщение из словаря score по проценту ошибок
    
    Args:
        error_percentage: Процент ошибок (0-100)
        score_dict: Словарь {процент_ошибок: сообщение}
    
    Returns:
        Выбранное сообщение
    """
    # 1. Отсортировать ключи по возрастанию
    # 2. Найти первый ключ, где error_percentage <= key
    # 3. Вернуть соответствующее сообщение
    pass
```

#### 4. Функция подстановки переменных

```python
def substitute_test_variables(
    text: str,
    score: float,
    max_score: float
) -> str:
    """
    Подставляет переменные {score} и {maxscore} в текст
    
    Args:
        text: Текст с переменными
        score: Набранные баллы
        max_score: Максимальные баллы
    
    Returns:
        Текст с подставленными переменными
    """
    # Заменить {score} и {maxscore} на значения
    # Округлить до 1 знака после запятой или до целого
    pass
```

#### 5. Обновление функций загрузки элементов

- `get_first_element_from_course()`: Добавить обработку `test` элементов
- `get_next_element_from_course()`: Добавить обработку `test` элементов
- `get_current_element_from_conversation()`: Добавить обработку `test` элементов из БД

#### 6. Endpoint для получения результата Test

```python
@router.get("/courses/{course_id}/test/result/{element_id}", response_model=TestResultResponse)
def get_test_result(
    course_id: str,
    element_id: str,
    chat_id: Optional[int] = Cookie(None),
    response: Response = None
):
    """
    Получает результат Test элемента
    
    Логика:
    1. Получить Test элемент из курса
    2. Вычислить total_score и total_max_score
    3. Вычислить процент ошибок
    4. Выбрать сообщение из score
    5. Подставить переменные в text
    6. Вернуть результат
    """
    pass
```

#### 7. Обновление функций сохранения

- `start_course()`: Сохранять `test` элементы в БД
- `next_element()`: Сохранять `test` элементы в БД

### Frontend (`webapp/frontend`)

#### 1. TypeScript интерфейсы

```typescript
interface TestElement {
  element_id: string
  type: "test"
  text: string
  prefix: string
  score: Record<number, string>  // { процент_ошибок: сообщение }
  button?: string
}

interface TestResult {
  total_score: number
  total_max_score: number
  error_percentage: number
  result_text: string
  feedback_message: string
}
```

#### 2. Компонент TestView

Создать компонент `webapp/frontend/components/chat/TestView.tsx`:

```typescript
interface TestViewProps {
  test: TestElement
  result?: TestResult
  onContinue?: () => void
  isLoading?: boolean
}

export default function TestView({ test, result, onContinue, isLoading }: TestViewProps) {
  // Отобразить:
  // 1. Результат с подставленными переменными (result_text)
  // 2. Выбранное сообщение (feedback_message)
  // 3. Кнопку "Продолжить" (если указана)
}
```

**Особенности компонента:**
- Показывает индикатор загрузки при вычислении результата
- Отображает результат с форматированием (жирный текст для чисел)
- Показывает выбранное сообщение из `score` с соответствующим стилем (зеленый/желтый/красный в зависимости от процента ошибок)
- Кнопка "Продолжить" вызывает `onContinue`

#### 3. Интеграция в ChatView

- Добавить обработку `test` элементов в `renderElement()`
- При загрузке Test элемента:
  1. Вызвать API endpoint `/api/mvp/courses/{course_id}/test/result/{element_id}`
  2. Получить результат
  3. Отобразить `TestView` с результатом

#### 4. Интеграция в page.tsx

- Добавить `TestElement` в тип `CourseElement`
- Добавить состояние для результатов Test элементов
- Добавить обработчик для кнопки "Продолжить" в TestView
- Обновить логику автоматического перехода (Test элементы не используют автоматический переход, если есть кнопка)

## Примеры использования

### Пример 1: Простой тест с префиксом

```yaml
Test_Score_01:
  type: quiz
  text: Выбери правильный ответ
  answers:
    - text: Правильно
      correct: yes
      feedback: ✅ Правильно!
    - text: Неправильно
      feedback: ❌ Неправильно.

Test_Score_02:
  type: quiz
  text: Еще один вопрос
  answers:
    - text: Правильно
      correct: yes
      feedback: ✅ Правильно!
    - text: Неправильно
      feedback: ❌ Неправильно.

Final_Test:
  type: test
  prefix: Test_Score_
  text: |
    *Ваш результат: {score} из {maxscore}.*
  score:
    0: ✅ Отлично! Вы набрали все баллы!
    50: ⚠️ Хорошо, но есть ошибки.
    100: ❌ Много ошибок. Рекомендуется повторить материал.
  button: Продолжить
```

### Пример 2: Тест с разными типами элементов

```yaml
q_input_1:
  type: input
  text: Введи правильный ответ
  correct_answer: тест
  feedback_correct: ✅ Правильно!
  feedback_incorrect: ❌ Неправильно.

q_quiz_1:
  type: quiz
  text: Выбери правильный ответ
  answers:
    - text: Правильно
      correct: yes
      feedback: ✅ Правильно!
    - text: Неправильно
      feedback: ❌ Неправильно.

q_multichoice_1:
  type: multi_choice
  text: Выбери все правильные ответы
  answers:
    - text: Вариант 1
      correct: yes
    - text: Вариант 2
      correct: no
    - text: Вариант 3
      correct: yes
  feedback_correct: ✅ Отлично!
  feedback_partial: ⚠️ Частично правильно.
  feedback_incorrect: ❌ Неправильно.

Final_Test:
  type: test
  prefix: q_
  text: |
    *Итоговый результат: {score} из {maxscore} баллов.*
  score:
    0: ✅ Превосходно! Вы идеально справились со всеми заданиями!
    33: ⚠️ Хорошо, но есть ошибки. Рекомендуется повторить материал.
    66: ⚠️ Есть ошибки. Стоит повторить материал.
    100: ❌ Много ошибок. Настоятельно рекомендуется повторить весь материал.
  button: Завершить
```

## Приоритеты реализации

### Приоритет 1 (Критично)
1. ✅ Backend: Pydantic модели для Test элемента
2. ✅ Backend: Функция подсчета баллов из БД
3. ✅ Backend: Функция выбора сообщения по проценту ошибок
4. ✅ Backend: Функция подстановки переменных в текст
5. ✅ Backend: Endpoint для получения результата Test
6. ✅ Backend: Обновление функций загрузки элементов

### Приоритет 2 (Важно)
7. ✅ Frontend: TypeScript интерфейсы
8. ✅ Frontend: Компонент TestView
9. ✅ Frontend: Интеграция в ChatView
10. ✅ Frontend: Интеграция в page.tsx

### Приоритет 3 (Желательно)
11. ✅ Обработка edge cases (отсутствие ответов, деление на ноль)
12. ✅ Форматирование чисел (округление)
13. ✅ Визуальное оформление результата (цвета в зависимости от процента ошибок)

## Тестирование

### Тестовые сценарии

1. **Базовый тест:**
   - Создать курс с несколькими quiz элементами с префиксом `q_`
   - Добавить Test элемент с `prefix: q_`
   - Ответить на все quiz элементы правильно
   - Проверить, что Test показывает правильный результат

2. **Тест с разными типами элементов:**
   - Создать курс с quiz, input и multi_choice элементами с префиксом
   - Добавить Test элемент
   - Ответить на все элементы
   - Проверить правильность подсчета баллов

3. **Тест с отсутствующими ответами:**
   - Создать курс с элементами с префиксом
   - Не ответить на некоторые элементы
   - Проверить, что отсутствующие ответы считаются как 0 баллов

4. **Тест с выбором сообщения:**
   - Создать Test элемент с несколькими диапазонами в `score`
   - Проверить правильность выбора сообщения для разных процентов ошибок

5. **Тест с подстановкой переменных:**
   - Проверить правильность подстановки `{score}` и `{maxscore}` в текст
   - Проверить форматирование чисел

6. **Тест с кнопкой:**
   - Проверить отображение кнопки "Продолжить"
   - Проверить переход к следующему элементу при нажатии

7. **Тест без кнопки:**
   - Проверить автоматический переход к следующему элементу

## Примечания

- Test элемент не требует ответа от пользователя, он только показывает результат
- Test элемент должен вычислять результат на основе уже сохраненных ответов пользователя
- Если пользователь еще не ответил на элементы с префиксом, они считаются как 0 баллов
- Процент ошибок вычисляется как `(maxscore - score) / maxscore * 100`, где 0% - все правильно, 100% - все неправильно
- Сообщения из словаря `score` выбираются по принципу "первое, где процент ошибок <= ключа", поэтому ключи должны быть отсортированы по возрастанию
