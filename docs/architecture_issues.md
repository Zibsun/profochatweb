# Недостатки архитектуры ProfoChat Web

Документ описывает основные архитектурные проблемы и недостатки текущей реализации веб-приложения на верхнем уровне.

> **Примечание:** Telegram бот был перенесен в отдельный репозиторий. Данный документ описывает только проблемы веб-приложения.

## Содержание

1. [Управление подключениями к базе данных](#управление-подключениями-к-базе-данных)
2. [Дублирование кода и логики](#дублирование-кода-и-логики)
3. [Разные подходы к работе с БД](#разные-подходы-к-работе-с-бд)
4. [Глобальные переменные и состояние](#глобальные-переменные-и-состояние)
5. [Отсутствие слоя абстракции](#отсутствие-слоя-абстракции)
6. [Проблемы масштабируемости](#проблемы-масштабируемости)
7. [Отсутствие тестирования](#отсутствие-тестирования)
8. [Слабая обработка ошибок](#слабая-обработка-ошибок)
9. [Монолитная структура](#монолитная-структура)
10. [Отсутствие кэширования](#отсутствие-кэширования)
11. [Смешение ответственности](#смешение-ответственности)
12. [Отсутствие единой системы миграций](#отсутствие-единой-системы-миграций)
13. [Проблемы с конфигурацией](#проблемы-с-конфигурацией)
14. [Отсутствие мониторинга и логирования](#отсутствие-мониторинга-и-логирования)

---

## Управление подключениями к базе данных

### Проблема

**Текущая реализация:**
- Каждая функция в `db.py` создает новое подключение через `get_connection()`
- Подключение закрывается сразу после выполнения операции
- Отсутствует пул подключений
- Нет переиспользования подключений

**Пример:**
```python
def get_current_element(chat_id):
    conn = get_connection()  # Новое подключение
    cursor = conn.cursor()
    # ... выполнение запроса ...
    conn.close()  # Закрытие подключения
    return result
```

### Последствия

1. **Производительность:**
   - Высокие накладные расходы на создание/закрытие подключений
   - При высокой нагрузке PostgreSQL может исчерпать лимит подключений
   - Медленная работа при большом количестве запросов

2. **Масштабируемость:**
   - Невозможность эффективно масштабировать систему
   - Проблемы при горизонтальном масштабировании (несколько инстансов приложения)

3. **Надежность:**
   - Риск утечек подключений при ошибках
   - Отсутствие управления транзакциями на уровне приложения

### Рекомендации

- Использовать пул подключений (`psycopg2.pool.ThreadedConnectionPool` или `asyncpg`)
- Внедрить connection pooling на уровне приложения
- Использовать контекстные менеджеры для автоматического управления подключениями
- Добавить мониторинг использования подключений

---

## Дублирование кода и логики

### Проблема

**Дублирование между компонентами:**

1. **Интеграция с ИИ:**
   - `chat.py` — полная реализация в Core Logic модулях
   - `webapp/backend/app/services/llm_service.py` — частично дублирует функциональность `chat.py`
   - Backend использует `chat.py` через `sys.path`, но также имеет собственную реализацию

2. **Работа с курсами:**
   - Логика работы с курсами в `course.py` (Core Logic)
   - Частичное дублирование в backend сервисах
   - Разные подходы к валидации и обработке данных

3. **Работа с базой данных:**
   - `db.py` — функции с прямыми SQL запросами (Core Logic)
   - `webapp/backend/app/models/` — SQLAlchemy модели для ORM
   - Два разных способа работы с одной и той же БД в одном приложении

### Последствия

1. **Поддержка:**
   - Необходимость поддерживать несколько реализаций
   - Риск расхождения функциональности между версиями
   - Сложность синхронизации изменений

2. **Качество кода:**
   - Исправления багов нужно вносить в несколько мест
   - Новые функции реализуются по-разному в разных компонентах
   - Усложнение тестирования

3. **Развитие:**
   - Замедление разработки новых функций
   - Сложность рефакторинга

### Рекомендации

- Унифицировать использование Core Logic модулей (`chat.py`, `course.py`, `db.py`)
- Убрать дублирование между `llm_service.py` и `chat.py` - использовать только `chat.py`
- Создать единый слой абстракции для работы с БД (либо только SQLAlchemy, либо только `db.py`)
- Применить принцип DRY (Don't Repeat Yourself)
- Рассмотреть реорганизацию Core Logic модулей в структуру `backend/app/core/`

---

## Разные подходы к работе с БД

### Проблема

**Веб-приложение использует два подхода одновременно:**

1. **Core Logic модули (`db.py`):**
   - Прямые SQL запросы через `psycopg2`
   - Функциональный подход
   - Ручное управление транзакциями
   - Отсутствие типизации
   - Используется модулями `course.py`, `elements/`

2. **Backend (`webapp/backend/app/models/`):**
   - SQLAlchemy ORM
   - Объектно-ориентированный подход
   - Автоматическое управление транзакциями через сессии
   - Типизация через Pydantic схемы
   - Используется для новых функций (пользователи, сессии чата, прогресс)

### Последствия

1. **Консистентность:**
   - Разное поведение при одинаковых операциях
   - Разные способы обработки ошибок
   - Разные паттерны валидации данных

2. **Миграции:**
   - Backend использует Alembic для новых таблиц
   - Core Logic модули (`db.py`) работают с существующими таблицами без миграций
   - Риск расхождения при изменении схемы существующих таблиц

3. **Разработка:**
   - Разработчикам нужно знать два подхода
   - Сложность перехода между компонентами
   - Разные паттерны кода

### Рекомендации

- Унифицировать подход к работе с БД
- Либо перевести Core Logic модули на SQLAlchemy, либо создать единый слой абстракции
- Использовать единую систему миграций (Alembic) для всех изменений схемы БД
- Внедрить единые паттерны работы с данными
- Рассмотреть создание репозиториев для абстракции доступа к данным

---

## Глобальные переменные и состояние

### Проблема

**Использование глобальных переменных и состояния:**

1. **Переменные окружения:**
   - `BOT_NAME`, `BOT_FOLDER`, `CONFIG_FILE` — читаются через `os.environ.get()`
   - Отсутствие централизованной валидации конфигурации
   - Разбросанные по коду вызовы `os.environ.get()`

2. **Состояние в памяти:**
   - Отсутствие явного управления состоянием приложения
   - Зависимость от глобального состояния через переменные окружения

3. **`course.py` и другие Core Logic модули:**
   - Использование переменных окружения напрямую
   - Отсутствие dependency injection для конфигурации

### Последствия

1. **Тестирование:**
   - Сложность изоляции тестов
   - Зависимость от глобального состояния
   - Проблемы с параллельным выполнением тестов

2. **Масштабируемость:**
   - Невозможность горизонтального масштабирования (несколько инстансов)
   - Состояние привязано к процессу
   - Проблемы при перезапуске процесса

3. **Надежность:**
   - Риск потери состояния при сбоях
   - Сложность отладки из-за скрытых зависимостей

### Рекомендации

- Создать централизованный модуль конфигурации (например, `backend/app/core/config.py`)
- Использовать `pydantic-settings` для валидации и управления конфигурацией
- Применить dependency injection для передачи конфигурации в Core Logic модули
- Хранить состояние приложения в базе данных или внешнем хранилище (Redis) при необходимости
- Использовать конфигурационные объекты вместо прямых вызовов `os.environ.get()`

---

## Отсутствие слоя абстракции

### Проблема

**Прямые зависимости:**

1. **От базы данных:**
   - Прямые SQL запросы в бизнес-логике (`db.py`)
   - Отсутствие репозиториев или DAO слоя
   - Смешение логики доступа к данным и бизнес-логики
   - Два разных подхода (SQLAlchemy ORM и прямые SQL) в одном приложении

2. **От внешних сервисов:**
   - Прямые вызовы OpenAI/Eleven Labs API в `chat.py`
   - Отсутствие абстракции для замены провайдеров
   - Сложность мокирования для тестов
   - Дублирование логики между `chat.py` и `llm_service.py`

3. **От Core Logic модулей:**
   - Backend напрямую импортирует модули из корня через `sys.path`
   - Отсутствие четкого интерфейса между слоями
   - Сложность рефакторинга и тестирования

### Последствия

1. **Тестируемость:**
   - Невозможность легко мокировать зависимости
   - Сложность unit-тестирования
   - Необходимость интеграционных тестов для всего стека

2. **Гибкость:**
   - Сложность замены компонентов
   - Привязка к конкретным библиотекам/сервисам
   - Сложность адаптации к изменениям API

3. **Поддерживаемость:**
   - Изменения в зависимостях требуют изменений во всем коде
   - Сложность рефакторинга

### Рекомендации

- Создать репозитории для работы с БД (Repository pattern)
- Использовать интерфейсы для внешних сервисов (LLM Provider, TTS Provider)
- Применить паттерн Dependency Injection для Core Logic модулей
- Рассмотреть реорганизацию Core Logic модулей в структуру `backend/app/core/`
- Создать четкие интерфейсы между Backend и Core Logic слоями

---

## Проблемы масштабируемости

### Проблема

**Ограничения текущей архитектуры:**

1. **Вертикальное масштабирование:**
   - Один процесс FastAPI обрабатывает все запросы (если не используется несколько workers)
   - Ограничения одного процесса (память, CPU)
   - Ограниченная возможность распределения нагрузки

2. **Горизонтальное масштабирование:**
   - Core Logic модули используют переменные окружения напрямую
   - Отсутствие внешнего хранилища состояния (Redis)
   - Проблемы с отложенными элементами (APScheduler в каждом инстансе)
   - Отсутствие распределенной очереди задач

3. **База данных:**
   - Отсутствие пула подключений в `db.py` (каждое подключение создается заново)
   - Риск исчерпания подключений при нескольких инстансах
   - Отсутствие read replicas для распределения нагрузки
   - Два разных подхода к работе с БД могут создавать конфликты

### Последствия

1. **Производительность:**
   - Ограничение пропускной способности одним процессом
   - Проблемы при пиковых нагрузках
   - Медленная обработка при большом количестве пользователей

2. **Надежность:**
   - Single point of failure
   - Невозможность graceful degradation
   - Проблемы при перезапуске процесса

### Рекомендации

- Вынести состояние во внешнее хранилище (Redis)
- Использовать message queue для распределения задач
- Внедрить connection pooling
- Рассмотреть использование read replicas для БД
- Использовать горизонтальное масштабирование через load balancer

---

## Отсутствие тестирования

### Проблема

**Текущее состояние:**

1. **Unit-тесты:**
   - Отсутствуют или минимальны
   - Сложность написания из-за глобальных зависимостей
   - Отсутствие моков для внешних сервисов

2. **Интеграционные тесты:**
   - Минимальное покрытие
   - Сложность настройки тестового окружения
   - Отсутствие CI/CD pipeline

3. **E2E тесты:**
   - Отсутствуют или минимальны
   - Сложность автоматизации тестирования веб-приложения

### Последствия

1. **Качество:**
   - Риск регрессий при изменениях
   - Сложность рефакторинга без уверенности в корректности
   - Отсутствие документации через тесты

2. **Разработка:**
   - Медленная разработка из-за ручного тестирования
   - Страх вносить изменения
   - Сложность онбординга новых разработчиков

### Рекомендации

- Внедрить unit-тесты с использованием pytest
- Создать интеграционные тесты для критических путей
- Настроить CI/CD pipeline
- Использовать test doubles (mocks, stubs) для внешних зависимостей
- Стремиться к покрытию кода тестами >80%

---

## Слабая обработка ошибок

### Проблема

**Текущая реализация:**

1. **Отсутствие единообразной обработки:**
   - Разные подходы в разных модулях
   - Часть функций не обрабатывает ошибки
   - Отсутствие централизованной обработки исключений

2. **Логирование:**
   - Непоследовательное логирование ошибок
   - Отсутствие структурированного логирования
   - Сложность отслеживания ошибок в production

3. **Восстановление:**
   - Отсутствие retry логики для внешних API
   - Нет graceful degradation
   - Пользователи видят технические ошибки

### Примеры проблем:

```python
# db.py - отсутствие обработки ошибок
def get_current_element(chat_id):
    conn = get_connection()  # Может упасть
    cursor = conn.cursor()
    cursor.execute(sql, (chat_id,))  # Может упасть
    result = cursor.fetchone()  # Может упасть
    conn.close()
    return result  # Может вернуть None без обработки
```

### Последствия

1. **Надежность:**
   - Непредсказуемое поведение при ошибках
   - Риск падения всего процесса
   - Потеря данных при сбоях

2. **UX:**
   - Пользователи видят технические ошибки
   - Отсутствие понятных сообщений об ошибках
   - Невозможность восстановления после ошибок

### Рекомендации

- Внедрить единую систему обработки ошибок
- Использовать структурированное логирование (structlog, loguru)
- Добавить retry логику для внешних API
- Реализовать graceful degradation
- Создать пользовательские исключения для разных типов ошибок
- Добавить мониторинг ошибок (Sentry, Rollbar)

---

## Монолитная структура

### Проблема

**Текущая архитектура:**

1. **Тесная связанность:**
   - Core Logic модули в корне проекта, Backend в `webapp/backend/`
   - Прямые зависимости через `sys.path` манипуляции
   - Сложность выделения отдельных сервисов
   - Отсутствие четких границ между слоями

2. **Развертывание:**
   - Frontend и Backend развертываются вместе (или отдельно)
   - Core Logic модули не могут быть развернуты независимо
   - Сложность обновления отдельных частей

3. **Технологический стек:**
   - Смешение разных подходов в одном проекте
   - Core Logic модули используют прямые SQL, Backend использует SQLAlchemy
   - Разные паттерны работы с данными в одном приложении

### Последствия

1. **Разработка:**
   - Сложность параллельной разработки
   - Риск конфликтов при слиянии изменений
   - Сложность онбординга новых разработчиков

2. **Развертывание:**
   - Невозможность независимого деплоя компонентов
   - Риск влияния изменений одного компонента на другие
   - Сложность отката изменений

### Рекомендации

- Реорганизовать Core Logic модули в структуру `backend/app/core/`
- Использовать четкое разделение модулей с явными интерфейсами
- Внедрить четкие границы между слоями (Core Logic, Services, API)
- Использовать dependency injection для слабой связанности
- Рассмотреть выделение Core Logic в отдельный Python пакет (если необходимо)

---

## Отсутствие кэширования

### Проблема

**Текущая реализация:**

1. **Загрузка курсов:**
   - Каждый раз чтение YAML файлов с диска
   - Парсинг YAML при каждом запросе
   - Отсутствие кэширования в памяти

2. **Запросы к БД:**
   - Повторяющиеся запросы без кэширования
   - Загрузка одних и тех же элементов курса
   - Отсутствие кэша для часто запрашиваемых данных

3. **Внешние API:**
   - Отсутствие кэширования ответов от OpenAI
   - Повторные запросы для одинаковых промптов
   - Отсутствие rate limiting

### Последствия

1. **Производительность:**
   - Медленная загрузка курсов
   - Высокая нагрузка на БД
   - Лишние запросы к внешним API

2. **Стоимость:**
   - Лишние расходы на внешние API (OpenAI)
   - Высокая нагрузка на БД увеличивает стоимость инфраструктуры

### Рекомендации

- Внедрить кэширование курсов в памяти (LRU cache)
- Использовать Redis для распределенного кэширования
- Кэшировать ответы от LLM для одинаковых промптов
- Добавить TTL для кэшированных данных
- Использовать cache invalidation при изменении данных

---

## Смешение ответственности

### Проблема

**Нарушение Single Responsibility Principle:**

1. **`course.py`:**
   - Управление курсами
   - Навигация по элементам
   - Работа с базой данных напрямую
   - Загрузка курсов из YAML и БД

2. **Backend сервисы:**
   - Смешение бизнес-логики и работы с БД
   - Использование как SQLAlchemy, так и прямых SQL через `db.py`
   - Отсутствие четкого разделения на слои

3. **Элементы (`elements/`):**
   - Определение структуры данных
   - Сохранение в БД напрямую
   - Бизнес-логика обработки ответов
   - Отсутствие разделения на модели и сервисы

### Последствия

1. **Поддерживаемость:**
   - Сложность понимания кода
   - Сложность внесения изменений
   - Риск внесения ошибок при изменениях

2. **Тестируемость:**
   - Сложность unit-тестирования
   - Необходимость мокирования множества зависимостей
   - Сложность изоляции компонентов

### Рекомендации

- Разделить ответственность на отдельные классы/модули
- Использовать паттерны Service Layer, Repository
- Выделить отдельные слои: Presentation, Business Logic, Data Access
- Применить принципы SOLID
- Использовать dependency injection для слабой связанности

---

## Отсутствие единой системы миграций

### Проблема

**Текущее состояние:**

1. **Backend:**
   - Использует Alembic для миграций новых таблиц
   - Версионирование схемы БД для новых функций

2. **Core Logic модули:**
   - Работают с существующими таблицами без миграций
   - Изменения схемы применяются вручную или через Alembic
   - Риск расхождения при изменении существующих таблиц

3. **Синхронизация:**
   - Миграции только для новых таблиц (SQLAlchemy модели)
   - Существующие таблицы (`conversation`, `run`, `course` и т.д.) не версионируются через Alembic
   - Сложность отслеживания изменений схемы существующих таблиц

### Последствия

1. **Надежность:**
   - Риск ошибок при изменении схемы
   - Сложность отката изменений
   - Проблемы при развертывании

2. **Разработка:**
   - Сложность координации изменений схемы
   - Риск конфликтов при параллельной разработке
   - Отсутствие истории изменений схемы

### Рекомендации

- Использовать единую систему миграций (Alembic) для всех изменений схемы БД
- Создать миграции для существующих таблиц (если еще не сделано)
- Хранить все миграции в одном месте (`webapp/backend/alembic/`)
- Автоматизировать применение миграций при развертывании
- Внедрить проверку совместимости схемы при запуске
- Документировать изменения схемы для существующих таблиц

---

## Проблемы с конфигурацией

### Проблема

**Разные источники конфигурации:**

1. **YAML файлы:**
   - `config.yaml` — общая конфигурация (используется `chat.py`)
   - `courses.yml` — список курсов
   - Файлы курсов в `scripts/`

2. **Переменные окружения:**
   - `.env` файлы для Backend
   - Системные переменные окружения
   - Прямые вызовы `os.environ.get()` в Core Logic модулях
   - Отсутствие централизованной валидации

3. **База данных:**
   - Настройки в таблице `gen_settings` (если используется)
   - Конфигурация курсов в БД

### Последствия

1. **Управление:**
   - Сложность отслеживания всех источников конфигурации
   - Риск конфликтов между источниками
   - Отсутствие валидации конфигурации

2. **Развертывание:**
   - Сложность настройки для разных окружений
   - Риск ошибок при копировании конфигурации
   - Отсутствие централизованного управления

### Рекомендации

- Использовать единый источник конфигурации
- Применить библиотеку для управления конфигурацией (pydantic-settings)
- Валидировать конфигурацию при запуске
- Использовать переменные окружения как основной источник
- Хранить конфигурацию в версионируемых файлах

---

## Отсутствие мониторинга и логирования

### Проблема

**Текущее состояние:**

1. **Логирование:**
   - Базовое логирование через `logging`
   - Неструктурированные логи
   - Отсутствие централизованного сбора логов
   - Сложность поиска проблем

2. **Мониторинг:**
   - Отсутствие метрик производительности
   - Нет мониторинга здоровья системы
   - Отсутствие алертов при проблемах
   - Нет отслеживания использования ресурсов

3. **Трассировка:**
   - Отсутствие distributed tracing
   - Сложность отслеживания запросов через систему
   - Нет понимания узких мест производительности

### Последствия

1. **Операционная работа:**
   - Сложность диагностики проблем
   - Медленная реакция на инциденты
   - Отсутствие проактивного мониторинга

2. **Производительность:**
   - Нет понимания узких мест
   - Сложность оптимизации
   - Отсутствие данных для принятия решений

### Рекомендации

- Внедрить структурированное логирование (JSON формат)
- Использовать централизованный сбор логов (ELK, Loki)
- Добавить метрики (Prometheus, StatsD)
- Внедрить мониторинг здоровья (health checks)
- Настроить алерты для критических метрик
- Использовать APM инструменты (New Relic, Datadog)
- Внедрить distributed tracing (Jaeger, Zipkin)

---

## Резюме

### Критические проблемы (требуют немедленного внимания)

1. **Управление подключениями к БД** — влияет на производительность и масштабируемость
2. **Отсутствие тестирования** — риск регрессий и сложность разработки
3. **Слабая обработка ошибок** — влияет на надежность и UX

### Важные проблемы (требуют планирования)

1. **Дублирование кода** — усложняет поддержку
2. **Разные подходы к БД** — влияет на консистентность
3. **Глобальные переменные** — проблемы с масштабированием и тестированием
4. **Отсутствие кэширования** — влияет на производительность и стоимость

### Средние проблемы (можно решать постепенно)

1. **Монолитная структура** — влияет на гибкость развертывания
2. **Смешение ответственности** — влияет на поддерживаемость
3. **Отсутствие мониторинга** — влияет на операционную работу
4. **Проблемы с конфигурацией** — влияет на управление

### Рекомендуемый порядок решения

1. **Фаза 1 (критично):**
   - Внедрить connection pooling
   - Добавить базовое тестирование
   - Улучшить обработку ошибок

2. **Фаза 2 (важно):**
   - Устранить дублирование кода
   - Унифицировать работу с БД
   - Убрать глобальные переменные
   - Внедрить кэширование

3. **Фаза 3 (улучшения):**
   - Рефакторинг для разделения ответственности
   - Внедрение мониторинга
   - Улучшение конфигурации
   - Рассмотрение разделения на микросервисы (если необходимо)

---

## Заключение

Текущая архитектура ProfoChat Web функциональна и работает, но имеет ряд недостатков, которые ограничивают масштабируемость, поддерживаемость и надежность системы. После переноса в отдельный репозиторий и очистки от зависимостей Telegram бота, основные проблемы связаны с:

1. **Двумя подходами к работе с БД** — SQLAlchemy ORM и прямые SQL запросы
2. **Структурой проекта** — Core Logic модули в корне, Backend в подпапке
3. **Отсутствием четких границ** между слоями приложения
4. **Дублированием логики** между Core Logic и Backend сервисами

Большинство проблем можно решить постепенно, начиная с критических вопросов производительности и надежности, затем переходя к улучшению архитектуры и качества кода.

Важно отметить, что многие проблемы взаимосвязаны, и решение одной может помочь решить другие. Например, реорганизация Core Logic модулей в структуру `backend/app/core/` решит проблемы с зависимостями, тестируемостью и смешением ответственности одновременно.
